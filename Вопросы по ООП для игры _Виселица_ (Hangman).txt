1. Способность объекта скрывать свое внутреннее устройство, согласно которому объект рассматривается как черный ящик, называется


– Абстракция
– Инкапсуляция (правильный ответ)
– Интерфейс
– Полиморфизм


2. Интерфейс класса определяется


– Его публичными методами и данными (правильный ответ)
– Его защищенными методами и данными
– Его закрытыми методами и данными
– Его конструктором
– Его деструктором


3. Конструктор класса это
– Специальный метод класса, выполняющий освобождение занимаемых объектом ресурсов
– Его базовый класс
– Специальный метод класса, выполняющий инициализацию начального состояния объекта (правильный ответ)
– Список инициализации
– Программист, выполняющий разработку и проектирование внутреннего устройства класса


4. Может ли метод, объявленный константным, изменять данные класса?


– Не может
– Может
– Не может изменять данные, объявленные константными
– Может изменять данные, объявленные мутабельными (правильный ответ)


5. Зачем нужен деструктор класса?
– Освободить единолично занимаемые ресурсы (правильный ответ)
– Уведомить систему о разрушении объекта
– Предотвратить неконтролируемое разрушение объекта
– Отправить сообщение в консоль в особом формате


6. При каком типе наследования класс-потомок наследует интерфейс класса-родителя?
– Публичное наследование (правильный ответ)
– Защищенное наследование
– Приватное наследование


7. Вместо наследования реализации во многих случаях может оказаться лучше использовать
– Полиморфизм
– Композицию (правильный ответ)
– Наследование интерфейса
– Защищённое наследование


8. Зачем объявлять методы класса виртуальными?
– Для поддержки виртуальных переменных
– Такие методы имеют возможность изменять данные текущего класса из класса-наследника
– Так требует стандарт C++17
– Для возможности задать альтернативную реализацию в классе-наследнике (правильный ответ)


9. Что нужно сделать разработчику на C++, если он не хочет, чтобы от его класса наследовались?
– Не объявлять деструктор класса виртуальных (правильный ответ)
– Объявить конструктор класса приватным
– Приватно унаследовать класс от пустого класса
– Объявить конструктор класса как final


10. Можно ли создать экземпляр абстрактного класса?
– Да
– Нет (правильный ответ)


11. Может ли порожденный класс обладать свойствами сразу нескольких родительских классов?
– Да, для этого есть полиморфизм
– Нет
– Да, для этого можно применить множественное наследование (правильный ответ)
– Да, для этого можно объявить методы чисто виртуальными


12. Почему ромбовидное наследование - плохо?
– Компилятор генерирует код для каждой ветки наследования, что приводит к "разбуханию" кода
– Не понятно, реализацию какого из родителей нужно использовать в дочернем классе (правильный ответ)
– Компиляция попадёт в вечный цикл из-за круговой зависимости
– Это не плохо, просто требует большей квалификации программиста


13. Как можно избавиться от оператора switch-case?
– С помощью наследования реализации
– С помощью инкапсуляции
– С помощью полиморфизма (правильный ответ)


14. Самая сильная взаимосвязь между классами в C++ достигается через:
– отношение дружбы (правильный ответ)
– наследование
– композицию


15. Может ли объект класса 1 получить доступ к приватным данным объекта класса 2?
– Нет, на то эти данные и приватные
– Да, если класс 1 приватно унаследован от класса 2
– Да, если класс 1 объявлен дружественным по отношению к классу 2 (правильный ответ)


16. Можно ли применить арифметическую операцию между объектами разных типов?
– Нет
– Да (правильный ответ)


17. Зачем нужен умный указатель?
– Он инкапсулирует в себе ответственность освобождения занимаемых ресурсов объекта (правильный ответ)
– Он оптимизирует работу с памятью оборачиваемого объекта
– Он предотвращает ошибку обращения к несуществующим данным по указателю


18. Какая разница между префиксным и постфиксным унарным плюсом?
– Префиксный возвращает новое значение, менее производительно
– Префиксный возвращает старое значение, менее производительно
– Префиксный возвращает новое значение, более производительный (правильный ответ)
– Префиксный возвращает старое значение, более производительный


19. К чему приводит использование обобщённого программирования?
– более "раздутый" код программиста, но, возможно, более компактный бинарный код
– более компактный код программиста, и более производительный бинарный код
– более компактный код программиста, но, возможно, более "раздутый" бинарный код (правильный ответ)
– более "раздутый" код программиста, но, возможно, более производительный бинарный код


20. Можно ли с помощью шаблонов проводить длительные вычисления на этапе компиляции?
– Да (правильный ответ)
– Нет